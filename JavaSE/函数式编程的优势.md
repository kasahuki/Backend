面向对象思想需要关注用什么对象完成什么事情，而函数式编程思想就类似于我们数学中的函数，它主要关注的是对数据进行了什么操作。

# 函数式编程的优势

- 易于使用**并发编程**，大数据量下，集合处理效率高：可以使用并行流，自动使用多线程方式处理。
- 代码可读性高
- 消灭嵌套地狱

例如，要查询未成年作家的评分在70分以上的作家的书籍，由于洋流影响所以作家和书籍可能出现重复，需要进行去重。

如果按照原来的写法，需要这么写：

```Java
List<Author> authors = new ArrayList<>();
List<Book> bookList = new ArrayList<>();
Set<Book> uniqueBookValues = new HashSet<>();
Set<Author> uniqueAuthorValues = new HashSet<>();

for (Author author : authors) {
    if (uniqueAuthorValues.add(author)) {
        if (author.getAge() < 18) {
            List<Book> books = author.getBooks();
            for (Book book : books) {
                 if (book.getScore() > 70) {
                     if (uniqueBookValues.add(book)) {
                         bookList.add(book);
                     }
                 }
            }
        }
    }
}

System.out.println(bookList);
```

但如果改用函数式编程，代码会变得非常简单：

```Java
List<Author> authors = new ArrayList<>();

List<Book> collect = authors.stream()
        .distinct()
        .filter(author -> author.getAge() < 18)
        .map(author -> author.getBooks())
        .flatMap(Collection::stream)
        .filter(book -> book.getScore() > 70)
        .distinct()
        .collect(Collectors.toList());
System.out.println(collect);
```

# 一、lambda表达式

# 概述

Lambda是IDK8中一个语法糖，他可以对 **某些****匿名内部类**（这类匿名内部类是一个接口，并且接口中只有一个抽象方法需要被重写） 的写法进行简化。

它是函数式编程思想的一个重要体现，让我们不用关注是什么对象，而是更关注我们对数据进行了什么操作，即只关注匿名内部类中抽象方法的 **参数（数据）**及 **函数体（操作）**。

**核心原则**：可推导可省略。参数类型如果可以推导出来，就可以省略。

**基本格式**：

```Java
(参数列表) -> {代码}
```

# 使用案例

## 例一

在创建线程并启动时，可以使用匿名内部类的写法：

```Java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("传统方式创建线程");
    }
}).start();
```

因为使用到了匿名内部类 Runnable 接口，并且该接口中只有 run() 一个抽象方法，所以可以使用Lambda的格式对其进行修改，如下所示：

```Java
// () -> {...} 中 () 相当于 run() 方法的参数列表, {...} 相当于 run() 方法的函数体
new Thread(() -> {
    System.out.println("Lambda方式创建线程");
}).start();
```

## 例二

例如，有如下一个方法：

```Java
public static int calculateNum(IntBinaryOperator op) {
    int a = 10;
    int b = 20;
    return op.applyAsInt(a, b);
}
```

该方法接收一个 IntBinaryOperator 类型的参数，并调用该参数中的 applyAsInt() 方法。IntBinaryOperator 是 JDK 内置的一个接口，接口源码如下：

```Java
@FunctionalInterface
public interface IntBinaryOperator {
    int applyAsInt(int left, int right);
}
```

可以看到该接口只有一个抽象方法，因此在调用 calculateNum() 方法时，传入自定义的 IntBinaryOperator 实现时，就可以使用 lambda 表达式来实现。

```Java
calculateNum((a, b) -> {
    return a + b;
});
```

甚至可以进一步简化：

```Java
calculateNum((a, b) -> a + b);
```

Tips：

在 IDEA 中，可以通过 **`Alt + Enter`** 快捷键来进行匿名内部类和Lambda表达式格式之间的转换。

- 在匿名内部类格式下，使用快捷键可以将其转为Lambda表达式；
- 在Lambda格式下，使用快捷键可以将其转为匿名内部类格式；

## 例三

现有方法定义如下：

```Java
public static void printNum(IntPredicate p) {
    int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    for (int i : a) {
        if (p.test(i)) {
            System.out.println(i);
        }
    }
}
```

其中 IntPredicate 是一个接口，接口源码如下：

```Java
@FunctionalInterface
public interface IntPredicate {

    boolean test(int value);

    default IntPredicate and(IntPredicate other) {
        Objects.requireNonNull(other);
        return (value) -> test(value) && other.test(value);
    }

    default IntPredicate negate() {
        return (value) -> !test(value);
    }

    default IntPredicate or(IntPredicate other) {
        Objects.requireNonNull(other);
        return (value) -> test(value) || other.test(value);
    }
}
```

先使用匿名内部类的方式调用该方法：

```Java
printNum(new IntPredicate() {
    @Override
    public boolean test(int value) {
        return value % 2 == 0;
    }
});
```

该接口中虽然不止一个方法，但是只有一个 test() 抽象方法必须被重写，其他方法是默认方法不需要被重写，因此，也可以使用 Lambda 表达式实现：

```Java
printNum((int value) -> {
    return value % 2 == 0;
});

// 进一步简写
printNum(value -> value % 2 == 0)
```

# 省略规则

在例二和例三的代码中，给出了两种 Lambda 表达式，一种是单纯省略方法名和接口名，保留完整参数列表和方法体；第二种是省略参数类型，以及return 关键字等。

**省略的规则如下：**

1. **参数类型可以省略；**
2. **方法只有==一个==参数时，==参数列表的括号==可以省略；**
3. **方法体只有==一句代码===时，==大括号==、==return关键字==和唯一一句代码的==分号==可以省略；**

# 二、Stream的使用

Java8的 Stream 使用的是函数式编程模式，它可以被用来对集合或数组进行链状流式的操作，可以更方便地让我们对集合或数组操作。

官方文档如下：

https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

# 案例

## 1. 数据准备

```Java
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class Author {
    private Long id;
    private String name;
    private Integer age;
    private String intro;
    private List<Book> books;
}
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class Book {
    private Long id;
    private String name;
    private String category;
    private Integer score;
    private String intro;
}
private static List<Author> getAuthors() {
    Author author1 = new Author(1L, "雷蒙多", 33, "简介1", null);
    Author author2 = new Author(2L, "亚拉索", 15, "简介2", null);
    Author author3 = new Author(3L, "易", 14, "简介3", null);
    Author author4 = new Author(3L, "易", 14, "简介3", null);

    List<Book> books1 = new ArrayList<>();
    List<Book> books2 = new ArrayList<>();
    List<Book> books3 = new ArrayList<>();

    books1.add(new Book(1L, "刀的两侧是光明与黑暗", "哲学,爱情", 88, "用一把刀划分了爱恨"));
    books1.add(new Book(2L, "一个人不能死在同一把刀下", "个人成长,爱情", 99, "讲述如何从失败中明悟真理"));

    books2.add(new Book(3L, "那风吹不到的地方", "哲学", 85, "带你用思维去领略世界的尽头"));
    books2.add(new Book(3L, "那风吹不到的地方", "哲学", 85, "带你用思维去领略世界的尽头"));
    books2.add(new Book(4L, "吹或不吹", "爱情,个人传记", 56, "一个哲学家的恋爱观注定很难把他所在的时代理解"));

    books3.add(new Book(5L, "你的剑就是我的剑", "爱情", 56, "无法想象一个武者能对他的伴侣这么的宽容"));
    books3.add(new Book(6L, "风与剑", "个人传记", 100, "两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢?"));
    books3.add(new Book(6L, "风与剑", "个人传记", 100, "两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢?"));
    author1.setBooks(books1);
    author2.setBooks(books2);
    author3.setBooks(books3);
    author4.setBooks(books3);
    
    return new ArrayList<>(Arrays.asList(author1, author2, author3, author4));
}
```

## 2. 快速入门

### 需求

用 getAuthors() 方法获取到作家的集合，打印出所有年龄小于18的作家的名字，并且要注意去重。

### 实现

因为List并不是stream对象，为此使用集合对象时需要先将其转换为stream对象，拿到stream流，然后才可以调用stream对象的方法进行过滤处理。这里先使用匿名内部类的方式实现。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()    // 将List转为Stream流对象
            .distinct()    // 去重，靠的是Author类中的@EqualsAndHashCode注解，如果没有这个注解就需要自己编写这两个方法
            .filter(new Predicate<Author>() {   // 调用filter对年龄进行过滤，首先使用匿名内部类的方式实现
                @Override
                public boolean test(Author author) {
                    return author.getAge() < 18;
                }
            })
            .forEach(new Consumer<Author>() {   // forEach方法用来遍历剩余的每个元素进行消费，也使用匿名内部类的方式实现
                @Override
                public void accept(Author author) {
                    System.out.println(author.getName());
                }
            });
}
```

随后改为Lambda表达式实现

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    
    authors.stream()    // 将List转为Stream流对象
            .distinct()    // 去重，靠的是Author类中的@EqualsAndHashCode注解，如果没有这个注解就需要自己编写这两个方法
            .filter(author -> author.getAge() < 18)   // 调用filter对年龄进行过滤
            .forEach(author -> System.out.println(author.getName()));  // forEach方法用来遍历剩余的每个元素进行消费
}
```

## 3. IDEA 快速查看 Stream 流程

首先将断点打在使用流的地方：

![img](https://fxmktmrxi6.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI5YTQ2YjFkNjEzZWQ0ZWJmYTIxMzE2YzJjMTViZDZfdGVDaWFnSE9QS0FMZWp1cDQ3SXRpWElUYUt0ekVkZTRfVG9rZW46RVNYd2JTeTNab0VlYzJ4MmNMbGNINGZ2bldiXzE3MzM5MjMzODg6MTczMzkyNjk4OF9WNA)

然后使用DEBUG运行程序，在DEBUG窗口查看【Current Stream Chain】

![img](https://fxmktmrxi6.feishu.cn/space/api/box/stream/download/asynccode/?code=OGUxZjE5ODBjMDRjOTYyZmU4YThjY2UyOTQ0MTA4ODlfYmFSdFJSVmp3aWJ6VHhXMHNKeDZMY2g0Wk5iVmVaWW1fVG9rZW46S0taMGJaOFV2bzNYVml4ZnVOd2NRZ3l0bm1oXzE3MzM5MjMzODg6MTczMzkyNjk4OF9WNA)

逐个方法对应的Tab就可以查看流的处理流程：

![img](https://fxmktmrxi6.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJiYWE1OTE2NmMzODIzOWFkOTI1ODBkNTgyMTc0NTZfVER3Qkpyc2hKM0JOdXRzVktDeDN1UjEyaTd3NjNIOTRfVG9rZW46SEVJc2JpOUg5b0x2UHp4OFZ6d2NIZjBSbkRmXzE3MzM5MjMzODg6MTczMzkyNjk4OF9WNA)

# 常用操作

## 1. 创建流

Java 中有两类集合，一类是单列集合，父接口为Collection，一类是双列集合，父接口为Map。根据集合对象的不同，有如下几种创建流的方式：

1. 单列集合（List、Set）：`集合对象.stream()`
   1. ```Java
      List<Author> authors = getAuthors();
      Stream<Author> stream = authors.stream();
      ```
2. 数组（`[]`）：`Arrays.stream(数组)` 或者 `Stream.of(数组)`
   1. ```Java
      Integer[] arr = {1, 2, 3, 4, 5};
      Stream<Integer> stream1 = Arrays.stream(arr);
      Stream<Integer> stream2 = Stream.of(arr);
      ```
3. 双列集合：转换为单列集合后再创建
   1. ```Java
      Map<String, Integer> map = new HashMap<>();
      map.put("xiaoxin", 19);
      map.put("ameng", 17);
      map.put("wukong", 16);
      
      Stream<Map.Entry<String, Integer>> stream = map.entrySet().stream();
      ```

## 2. 中间操作

### filter

**[filter](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-)**(**[Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> predicate)：对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。

例如：打印所有姓名长度大于1的作家的姓名。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .filter(author -> author.getName().length() > 1)
            .forEach(author -> System.out.println(author.getName()));
}
```

### map

**[map](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-)**(**[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**,? extends R> mapper)：对流中的元素进行计算或类型转换。

例如：打印所有作家的姓名。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .map(author -> author.getName())
            .forEach(name -> System.out.println(name));
}
```

当然，其实这个需求单独用forEach也可以实现。但是经过map操作之后，流中的数据类型会改变，一定程度上减轻了数据量级。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .forEach(author -> System.out.println(author.getName()));
}
```

### distinct

**[distinct](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#distinct--)**()：可以去除流中的重复元素。

注意：distinct方法是依赖类中的equals方法来判断是否是相同对象的，所以如果要对某个类型的对象进行去重，这个类中必须重写equals() 和 hashCode() 方法。

例如：打印所有作家的姓名，并且要求其中不能有重复元素。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .distinct()
            .forEach(author -> System.out.println(author.getName()));
}
```

### sorted

- **[sorted](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted--)**()：对数据流中的元素按自然顺序排序。
- **[sorted](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted-java.util.Comparator-)**(**[Comparator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> comparator)：根据提供的Comparator对流中的元素排序。

例如：对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。

在这个案例中，如果要使用第一种方法，就必须让 Author 继承 Comparable 接口，并实现 compareTo() 方法定义排序规则。

```Java
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class Author implements Comparable<Author> {
    private Long id;
    private String name;
    private Integer age;
    private String intro;
    private List<Book> books;

    @Override
    public int compareTo(Author o) {
        // 升序排序
        // return this.getAge() - o.getAge();
        // 降序排序
        return o.getAge() - this.getAge();
    }
}
```

然后在main函数中调用：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .distinct()
            .sorted()
            .forEach(author -> System.out.println(author.getAge()));
}
```

第二种方式就是保持Author不动，不让 Author 实现 Comparable 接口，而是在 `sorted()` 中定义排序规则。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .distinct()
            .sorted((o1, o2) -> o2.getAge() - o1.getAge()) // 降序排列
            .forEach(author -> System.out.println(author.getAge()));
}
```

### limit

**[limit](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#limit-long-)**(long maxSize)：设置流的最大长度（元素数量），超出的部分将被舍弃。

例如，对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素，然后打印其中年龄最大的两个作家的姓名。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .distinct()
            .sorted((o1, o2) -> o2.getAge() - o1.getAge()) // 降序排列
            .limit(2)
            .forEach(author -> System.out.println(author.getAge()));
}
```

### skip

**[skip](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#skip-long-)**(long n)：跳过流中的前 n 个元素，返回剩下的元素。

例如，打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .distinct()
            .sorted((o1, o2) -> o2.getAge() - o1.getAge()) // 降序排列
            .skip(1)
            .forEach(author -> System.out.println(author.getAge()));
}
```

### flatMap

**[flatMap](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#flatMap-java.util.function.Function-)**(**[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**,? extends **[Stream](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**<? extends R>> mapper)：`map` 只能把一个对象转换成另一个对象来作为流中的元素，而fatMap可以把一个对象转换成多个对象作为流中的元素。

例如，打印所有书籍的名字，并对重复的元素进行去重。

刚开始可能会想到使用map()方法，取出author中的books列表，然后进行去重：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .map(author -> author.getBooks())
            .distinct()
            .forEach(System.out::println);
}
```

但是，map()返回的是author中的List<Book>对象，使用distinct进行去重时，流中的元素为List<Book>，而不是Book，因此去重的结果并不是我们预期的。

这时，就可以使用flatMap()，将流中列表类型的元素转换为新的流，新流中包含的就是列表中的元素，再使用distinct去重时，去重的对象就是Book对象了。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    // 匿名内部类形式
    authors.stream()
            .flatMap(new Function<Author, Stream<?>>() {
                @Override
                public Stream<?> apply(Author author) {
                    return author.getBooks().stream();
                }
            })
            .distinct()
            .forEach(System.out::println);

    // Lambda
    authors.stream()
            .flatMap(author -> author.getBooks().stream())
            .distinct()
            .forEach(System.out::println);
}
```

例二：打印现有书籍的所有分类，要求对分类进行去重，且不能出现多个分类（爱情,文艺）的格式

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    authors.stream()
            .flatMap(author -> author.getBooks().stream())
            .distinct()
            .flatMap(book -> Arrays.stream(book.getCategory().split(",")))
            .distinct()
            .forEach(System.out::println);
}
```

## 3. 结尾操作

**必须要有结尾操作，中间操作才会被调用到，进而生效，否则中间操作不会被执行**。

### forEach

**[forEach](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-)**(**[Consumer](https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> action)：对流中的元素进行遍历操作，可以通过传入的参数指定对遍历到的元素进行什么具体操作。

### count

**[count](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--)**()：获取当前流中元素的个数。

### max&min

- **[max](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-)**(**[Comparator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> comparator)：通过传入的Comparator对元素进行比较，得到最大值；
- **[min](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-)**(**[Comparator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> comparator)：通过传入的Comparator对元素进行比较，得到最小值。

Comparator的实现方法和 sorted() 中一致。

例如，获取这些作家的所出书籍的最高分并打印（最低分同理，改为min即可）。

此外，max和min返回的是一个Optional对象，需要通过 `get()` 获取到原始对象才可以使用。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Optional<Book> max = authors.stream()
            .flatMap(author -> author.getBooks().stream())
            .distinct()
            .max((o1, o2) -> o1.getScore() - o2.getScore());
    if (max.isPresent()) {
        Book book = max.get();
        System.out.println(book.getScore());
    }
    // 上面对max进行判断与输出的代码，也可以简化为Lambda表达式如下
    max.ifPresent(book -> System.out.println(book.getScore()));

    // 因为这里最后只需要输出分数，因此当我们取到 Stream<Book> 流对象后
    // 可以将流转换为 Stream<Integer> 流，只包含分数就可以，降低数据量级
    Optional<Integer> maxed = authors.stream()
            .flatMap(author -> author.getBooks().stream())
            .distinct()
            .map(book -> book.getScore())
            .max((o1, o2) -> o1 - o2);
    maxed.ifPresent(score -> System.out.println(score));
}
```

### collect

**[collect](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.stream.Collector-)**(**[Collector](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**,A,R> collector)：将当前流转换为一个集合。

在某些场景下，集合通过流处理之后，需要导出为一个新的集合进行使用，这时候就需要使用 `collect()` 方法。

例子：

获取一个存放所有作者名字的List集合。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    List<String> nameList = authors.stream()
            .map(author -> author.getName())
            .collect(Collectors.toList());

    System.out.println(nameList);
}
```

获取一个所有书名的Set集合。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Set<String> bookSet = authors.stream()
            .flatMap(author -> author.getBooks().stream())
            .map(book -> book.getName())
            .collect(Collectors.toSet());
    System.out.println(bookSet);
}
```

获取一个Map集合，map的key为作者名，value为`List<Book>`。

由于 `toMap()` 的匿名内部类比较复杂，先给出匿名内部类的方式，便于理解原理。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Map<String, List<Book>> books = authors.stream()
            .collect(Collectors.toMap(new Function<Author, String>() {
                @Override
                public String apply(Author author) {
                    return author.getName();
                }
            }, new Function<Author, List<Book>>() {
                @Override
                public List<Book> apply(Author author) {
                    return author.getBooks();
                }
            }, new BinaryOperator<List<Book>>() {
                @Override
                public List<Book> apply(List<Book> books1, List<Book> books2) {
                    return books2;
                }
            }));
    System.out.println(books);
}
```

使用toMap()方法有一个注意事项，toMap()共有三种实现：

- **[toMap](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-)**(**[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends K> keyMapper, **[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends U> valueMapper)
- **[toMap](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-)**(**[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends K> keyMapper, **[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends U> valueMapper, **[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<U> mergeFunction)
- **[toMap](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-java.util.function.Supplier-)**(**[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends K> keyMapper, **[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends U> valueMapper, **[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<U> mergeFunction, **[Supplier](https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html)**<M> mapSupplier)

主要是前三个参数：

- **[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends K> keyMapper：key的映射函数，将T类型映射为K类型
- **[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super T,? extends U> valueMapper：value的映射函数，将T类型映射为U类型
- **[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<U> mergeFunction：聚合函数，用于指定key重复时的操作

因为将流中元素的某个字段转化为key后是可能存在重复的，并且无法通过distinct()去重，distinct()只会去掉重复的对象，而不能仅对流中元素的某个字段去重。

BinaryOperator<U>则是用来指导key重复时的聚合规则，实现BinaryOperator<U>接口需要重写apply(o1, o2)方法，接收两个参数，如果 return o1 则表示保留先出现的key对应的value，return o2 则表示用后面出现的key对应的value覆盖前面的。

随后，用Lambda表达式简化：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Map<String, List<Book>> books = authors.stream()
            .collect(Collectors.toMap(author -> author.getName(), author -> author.getBooks(), (books1, books2) -> books2));
    System.out.println(books);
}
```

### 查找与匹配

#### anyMatch

**[anyMatch](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#anyMatch-java.util.function.Predicate-)**(**[Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> predicate)：判断流内是否有任意符合匹配条件的元素，结果为boolean类型。只要有一个元素满足条件就返回true。

例如，判断是否有年龄在29岁以上的作家。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    boolean b = authors.stream()
            .anyMatch(author -> author.getAge() > 29);
    System.out.println(b);  // true
}
```

#### allMatch

**[allMatch](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#allMatch-java.util.function.Predicate-)**(**[Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> predicate)：与anyMatch()类似，判断流内是否所有元素都满足匹配条件，结果为boolean类型。当所有元素都满足条件时才返回true。

#### noneMatch

**[noneMatch](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#noneMatch-java.util.function.Predicate-)**(**[Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> predicate)：与上面两个类似，判断流内是否所有元素都不满足匹配条件，结果为boolean类型。当所有元素都不满足条件时才返回true。

#### findAny

**[findAny](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#findAny--)**()：获取流中的任意一个元素，返回的是一个 **`Optional`** 对象。该方法没有办法保证获取的一定是流中的第一个元素，因此用的更多的是下面的 findFirst() 方法。

例子：获取任意一个年龄大于18的作家，如果存在就输出他的名字。

findAny() 并不像他的字面意思一样，可以查找一个满足条件的元素，他只是在最后处理完的流中随机获取一个元素并返回。因此，如果要做筛选的话，还是要依赖 filter() 方法。

**那么 findAny() 和 findFirst() 存在的意义是什么呢？**

因为流处理结束后，最终的流是可能为空的，比如说下面的代码中，如果作家年龄都小于18，那么最后的流将会是空的，如果直接使用很可能会报空指针异常。因此，findAny() 和 findFirst() 方法主要是用来避免空指针异常的。

当调用 findAny() 和 findFirst() 方法时，返回的是一个 Optional 对象，Optional 对象的 ifPresent() 方法便可以对流元素对象进行判空，不为空才执行相应逻辑。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    // 查找年龄大于18的作家
    Optional<Author> optionalAuthor = authors.stream()
            .filter(author -> author.getAge() > 18)
            .findAny();
    
    // 如果存在就输出他的名字
    optionalAuthor.ifPresent(author -> System.out.println(author));
}
```

#### findFirst

**[findFirst](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#findFirst--)**()：获取流中的第一个元素，返回的是一个 **`Optional`** 对象。与findAny()的用法一样。

### reduce

对流中的数据按照指定的计算方式计算出 **一个结果**。有三种实现：

- **[reduce](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-)**(**[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<**[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> accumulator)：返回的是 Optional<T> 对象
- **[reduce](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-)**(**[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)** identity, **[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<**[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> accumulator)：返回的是 T 类型的对象
- **[reduce](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-U-java.util.function.BiFunction-java.util.function.BinaryOperator-)**(U identity, **[BiFunction](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)**<U,? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**,U> accumulator, **[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<U> combiner)：返回的是 <U> U 类型的对象。

#### 两个参数

**[reduce](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-)**(**[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)** identity, **[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<**[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> accumulator) 的作用是把 `stream` 中的元素给组合起来，我们可以传入一个初始值，它会按照传入的计算方式依次取出流中的元素和初始化值一起进行计算，计算结果后再和后面的元素计算。

他内部的计算方式如下：

```Java
// 定义初始值
T result = identity;
for (T element : this.stream)
    // 逐个取出流中的元素，按照apply中定义的逻辑与初始值进行计算
    result = accumulator.apply(result, element)
return result;
```

其中identity就是我们通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。

例子：

1. 使用reduce求所有作者年龄的和。

先用匿名内部类的方式实现，第二个参数定义了一个 BinaryOperator() 并实现了 apply() 方法，定义聚合操作为 加法，注意传入的参数，第一个表示result，第二个表示流遍历到的元素。 

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Integer ageSum = authors.stream()
            .distinct()
            .map(Author::getAge)
            .reduce(0, new BinaryOperator<Integer>() {
                @Override
                public Integer apply(Integer result, Integer element) {
                    return result + element;
                }
            });
}
```

再用Lambda表达式简化：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Integer ageSum = authors.stream()
            .distinct()
            .map(Author::getAge)
            .reduce(0, (result, element) -> result + element);
}
```

1. 使用reduce求所有作者中年龄的最大值。

实际上使用 max() 也可以实现这个操作，但是 max() 在底层其实也是调用的 reduce() 方法，并且在开发中有时候需要求一些其它类型的统计值，因此，还是看看如何使用 reduce() 来实现 max() 的功能。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Integer maxAge = authors.stream()
            .map(Author::getAge)
            .reduce(Integer.MIN_VALUE, (result, element) -> result < element ? element : result);
}
```

#### 单个参数

**[reduce](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-)**(**[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html)**<**[T](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)**> accumulator) 的作用和两参的 reduce() 作用一样，只是将流中的第一个元素作为初始值，而不是传入自定义的初始值，然后依然是按照 accumulator 中定义的操作进行计算。

其内部的调用原理如下所示：

```Java
boolean foundAny = false;
T result = null;  // 上面是将传入的identity作为result初始值
for (T element : this stream) {
    if (!foundAny) {  // 找出第一个元素，用来初始化result
        foundAny = true;
        result = element;
    } else {
        result = accumulator. apply(result, element);
    }
}
return foundAny ? Optional. of(result) : Optional. empty();
```

如果用单参数的 reduce() 实现求年龄最大值，代码如下：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Optional<Integer> reduce = authors.stream()
            .map(Author::getAge)
            .reduce((result, element) -> result > element ? result : element);
}
```

accumulator 的参数中同样是，第一个表示result，第二个表示遍历到的流中的元素。

# 注意事项

1. 惰性求值：
   1. 在对流进行操作时，操作不会立即执行，而是等到需要结果时才进行计算，即没有结尾操作，中间操作是不会执行的。
   2. 这种延迟计算的特性可以提高性能，因为它只计算流中实际需要的元素，而不是对整个流进行操作。
2. 流是一次性的（One-Time Use）：
   1. Stream 流是一次性的，一旦对流进行了结尾操作（如收集结果、循环遍历等），流就会被消耗掉，无法再次使用。
   2. 如果需要对同一组数据进行多个操作，可以创建一个新的流来进行操作。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();

    Stream<Author> stream = authors.stream();
    // 第一次对流进行处理，并执行了结尾操作
    stream.forEach(System.out::println);
    // 流终结后再次使用流，报错！！！
    stream.forEach(System.out::println);
}
```

1. 不会影响原数据：
   1. Stream 流的操作不会直接修改原始数据源中的元素，也不会影响原始数据源的结构。
   2. 所有的流操作都是基于数据源的副本或视图进行的，保持了原始数据的不变性。
   3. 除非在流中调用了流中元素对象的setter类似的方法，例如：
      - ```Java
        public static void main(String[] args) {
            List<Author> authors = getAuthors();
        
            authors.stream()
                    .map(new Function<Author, Object>() {
                        @Override
                        public Object apply(Author author) {
                            author.setAge(author.getAge() + 10);
                            return author;
                        }
                    }).forEach(System.out::println);
        }
        ```

# 三、Optional

# 概述

在从数据库查询数据或者执行一些其他操作的时候，查询出来的结果可能是为空的，返回的是 `null`，如果不对返回值进行判断，直接对 `null` 进行操作，则会报空指针异常。

传统的方式是使用 `if` 条件判断来判断对象是否为空，并执行相应的处理逻辑：

```Java
if (authors != null) {
    System.out.println(author.getName());
}
```

如果存在大量的非空判断，代码就会显得十分臃肿，可读性也会降低。因此 Java 8 引入了 **`Optional`** 类，用于处理可能为空的值的容器类。它提供了一种优雅的方式来处理可能存在或不存在的值，**避免了空指针异常的发生**。

官方文档如下：

https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html

以下是 Optional 类的一些重要特点和用法：

- **容器类**：Optional 是一个容器类，可以包含一个非空的值或者为空。它通过 of()、ofNullable() 和 empty() 等静态方法来创建 Optional 对象。
- **避免空指针异常**：Optional 提供了一种安全的方式来处理可能为空的值。通过使用 Optional，我们可以避免显式地进行空值检查，从而减少了空指针异常的风险。
- **方法链操作**：Optional 提供了一系列方法来对包含的值进行操作，如 map()、flatMap()、filter() 等。这些方法可以在值存在的情况下进行操作，并返回一个新的 Optional 对象。
- **`isPresent()`** **和** **`ifPresent()`**：Optional 提供了 isPresent() 方法来检查值是否存在，以及 ifPresent() 方法来在值存在时执行特定的操作。
- **默认值**：Optional 提供了 orElse()、orElseGet() 和 orElseThrow() 等方法来获取值或者提供默认值，以应对值为空的情况。
- **空值处理**：Optional 提供了 ifPresentOrElse() 方法来在值存在或者为空时执行不同的操作。

使用 Optional 类可以使代码更加健壮和可读，同时提供了一种优雅的方式来处理可能为空的值。

# 使用

## 1. 创建对象

Optional 就好像是包装类，可以把我们的具体数据封装到 `Optional` 对象内部。然后去使用 `Optional` 中封装好的方法操作封装进去的数据就可以避免空指针异常。

### ofNullable

一般使用 `Optional` 的静态方法 `ofNullable`（**[ofNullable](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#ofNullable-T-)**(T value)）来把数据封装成一个 `Optional` 对象。如果传入的参数为`null`，将会返回一个空的 Optional 对象。

```Java
public static void main(String[] args) {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.ofNullable(author);
    optionalAuthor.ifPresent(System.out::println);
}
```

这样处理感觉和使用 `if` 做判空好像差不多，在获取数据后都要加一行代码来处理。但是如果改造下 `getAuthor` 方法，让其的返回值就是封装好的 `Optional` 的话，我们在使用时就会方便很多。

而且在实际开发中，数据很多是从数据库获取的，MyBatis 从 3.5 版本开始也已经支持 Optional 了，可以直接把 Dao 层方法的返回值类型定义成 Optional 类型，封装的过程也不需要自己操作，MyBatis 会自己把数据封装成 Optional 对象返回。

### of

**[of](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#of-T-)**(T value)：of 方法只能处理非空的对象。如果确定一个对象不是空的，则可以使用 `of` 方法来把数据封装成 Optional 对象。

### empty

**[empty](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#empty--)**()：返回一个空的 Optional 对象。如果明确知道某个对象为 null，那么可以直接使用 empty() 封装。

> ofNullable() 本质也是调用 of() 和 empty() 实现的：
>
> ```Java
> public static <T> Optional<T> ofNullable(T value) {
>     return value == null ? empty() : of(value);
> }
> ```

## 2. 安全消费值

**[ifPresent](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#ifPresent-java.util.function.Consumer-)**(**[Consumer](https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)**> consumer)：如果 Optional 对象中的对象不为 null，那么就会调用 consumer 中定义的逻辑处理，如果为 null，则不执行任何操作。

获取到一个 Optional 之后，可以使用其 ifPresent() 方法来消费其中的值。这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码，这样使用起来就更加安全了。

例如，以下写法就避免了空指针异常。

```Java
public static void main(String[] args) {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.ofNullable(author);
    optionalAuthor.ifPresent(System.out::println);
}
```

## 3. 获取值

**[get](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#get--)**()：如果 Optional 中的值不为 null，则返回该对象，如果为空，则会抛 NoSuchElementException 异常。

如果想获取值自己进行处理，可以使用 `get()` 方法获取，但是因为空的 Optional 调用 get() 会抛异常，因此还需要使用 **[isPresent](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#isPresent--)**() 方法判断 Optional 中值是否存在，如果存在返回 true，否则返回 false。

```Java
public static void main(String[] args) {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.of(author);
    if (optionalAuthor.isPresent()) {
        Author author2 = optionalAuthor.get();
        System.out.println(author2);
    }
}
```

但是这种方式和直接对对象进行判空差不多，因此，建议直接使用 `ifPresent` 方法。

## 4. 安全获取值

直接使用 get() 方法获取值还是可能存在异常问题，因此，如果期望安全地获取值，可以使用 Optional 的下列方法。

### orElseGet

**[orElseGet](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseGet-java.util.function.Supplier-)**(**[Supplier](https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html)**<? extends **[T](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)**> other)：如果存在则返回值，否则返回设置好的默认值。

例如：

```Java
public static void main(String[] args) {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.of(author);
    Author author2 = optionalAuthor.orElseGet(new Supplier<Author>() {
        @Override
        public Author get() {
            return new Author();
        }
    });
}
```

改用 Lambda 表达式

```Java
public static void main(String[] args) {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.of(author);
    Author author2 = optionalAuthor.orElseGet(() -> new Author());
}
```

### orElseThrow

**[orElseThrow](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseThrow-java.util.function.Supplier-)**(**[Supplier](https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html)**<? extends X> exceptionSupplier)：如果存在则返回值，否则抛出 Supplier 指定的异常。

该方法在 Spring 框架中用的比较多，可以用 Spring 来做统一的异常捕获。

```Java
public static void main(String[] args) throws Throwable {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.of(author);
    Author author2 = optionalAuthor.orElseThrow(new Supplier<Throwable>() {
        @Override
        public Throwable get() {
            return new RuntimeException();
        }
    });
}
```

改为 Lambda 表达式：

```Java
public static void main(String[] args) throws Throwable {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.of(author);
    Author author2 = optionalAuthor.orElseThrow(() -> new RuntimeException());
}
```

## 5. 过滤

**[filter](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#filter-java.util.function.Predicate-)**(**[Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)**> predicate)：如果存在值并且值满足设定的条件，返回满足条件的元素组成的 Optional，否则返回空的 Optional。

```Java
public static void main(String[] args) throws Throwable {
    Author author = getAuthor();
    Optional<Author> optionalAuthor = Optional.ofNullable(author);
    optionalAuthor.filter(author1 -> author1.getAge() > 18).ifPresent(author1 -> System.out.println(author1.getName()));
}
```

## 6. 判断

**[isPresent](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#isPresent--)**()：对Optional对象中是否存在值进行判断，如果存在返回true，否则返回false。

一般都是直接使用 `ifPresent()`，单独使用 `isPresent()` 和使用 `if(xx != null)` 差不多。

## 7. 数据转换

**[map](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#map-java.util.function.Function-)**(**[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)**<? super **[T](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)**,? extends U> mapper)：与 Stream 中的 map() 方法类似，用于数据转换或计算。

例如获取作家书籍的集合：

```Java
public static void main(String[] args) throws Throwable {
    Optional<Author> optionalAuthor = Optional.ofNullable(getAuthor());
    // 使用map将 Optional<Author> 转换为 Optional<List<Book>>
    Optional<List<Book>> optionalBooks = optionalAuthor.map(new Function<Author, List<Book>>() {
        @Override
        public List<Book> apply(Author author) {
            return author.getBooks();
        }
    });
    // 如果Optional<List<Book>> 不为空，取出数据进行消费。
    optionalBooks.ifPresent(new Consumer<List<Book>>() {
        @Override
        public void accept(List<Book> books) {
            // 遍历books
            books.forEach(new Consumer<Book>() {
                @Override
                public void accept(Book book) {
                    System.out.println(book.getName());
                }
            });
        }
    });
}
```

改为 Lambda 表达式：

```Java
public static void main(String[] args) throws Throwable {
    Optional<Author> optionalAuthor = Optional.ofNullable(getAuthor());
    Optional<List<Book>> optionalBooks = optionalAuthor.map(author -> author.getBooks());
    optionalBooks.ifPresent(books -> books.forEach(book -> System.out.println(book.getName())));
}
```

# 四、函数式接口

函数式接口（Functional Interface）是指 **只包含一个抽象方法** 的接口。Java 8 引入了函数式接口的概念，以支持函数式编程的特性。

JDK 内置的函数式接口都加上了 `@FunctionalInterface` 注解，但是并非加这个注解的才是函数式接口，只要满足“只包含一个抽象方法”，就是函数式接口。

以下是函数式接口的一些特点和用途：

- **单一抽象方法**：函数式接口只能包含一个抽象方法，可以有默认方法和静态方法，但只能有一个抽象方法。这个抽象方法定义了接口的核心功能。
- **Lambda 表达式**：函数式接口可以使用 Lambda 表达式来创建接口的实例。Lambda 表达式提供了一种简洁的方式来定义函数式接口的实现。
- **方法引用**：函数式接口可以使用方法引用来引用已有的方法作为接口的实现。方法引用提供了一种更简洁的方式来表示函数式接口的实现。
- **Java 8 Stream API**：Java 8 的 Stream API 中广泛使用了函数式接口。Stream API 提供了一种流式操作的方式，可以对集合进行过滤、映射、排序等操作。

# 常用函数式接口

常用的函数式接口包括 [Runnable](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html)、[Comparator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)、[Consumer](https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html)、[Function](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html)、[Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) 等。

Java 8 提供了一些内置的函数式接口，如 [Supplier](https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html)、[UnaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)、[BinaryOperator](https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html) 等。

# 函数式接口常用默认(default)方法

## Predicate

### and

![img](https://fxmktmrxi6.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU1MTNhNTE5ZDYyNTUyZmExMzExMjAxNjVkZjc4NzFfSTJ1cUc2ODI4UWJOUE1OcXJYNEVORWNNNnNTblBoaXRfVG9rZW46VkU1bGJQdTlEb3hmYkF4dkJPN2NnRjg5bkJmXzE3MzM5MjM0NDE6MTczMzkyNzA0MV9WNA)

在使用 Predicate 接口时，可能需要进行判断条件的拼接，而 and() 方法相当于使用 `&&` 来拼接两个判断条件。

例如：打印作家中年龄大于17并且姓名的长度大于1的作家。

> 当然这里用两个 `filter()` 也可以，或者是在一个 Predicate 里面用 `&&` 连接判断。

先用匿名内部类实现：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .filter(new Predicate<Author>() {
                @Override
                public boolean test(Author author) {
                    return author.getAge() > 17;
                }
            }.and(new Predicate<Author>() {
                @Override
                public boolean test(Author author) {
                    return author.getName().length() > 1;
                }
            }))
            .forEach(System.out::println);
}
```

改用Lambda表达式：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .filter(((Predicate<Author>) author -> author.getAge() > 17).and(author -> author.getName().length() > 1))
            .forEach(System.out::println);
}
```

### or

![img](https://fxmktmrxi6.feishu.cn/space/api/box/stream/download/asynccode/?code=MGYxNDM1YzY5YzkwNDI5NTE5MmJmMjI5ZWM2NzQ5YmZfeHcybHZLaGZRcHNDaGpKbWp5Z0ZXdThlSk9pS1k2MmVfVG9rZW46V1JMUGJMV3JVb0V5T2J4djZTU2NRdWJzbnZmXzE3MzM5MjM0NDE6MTczMzkyNzA0MV9WNA)

or 与 and 类似，相当于用 `||` 来拼接两个判断条件。

### negate

![img](https://fxmktmrxi6.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk2MzMxOTJiZGQwNThmZTc1ODU4ZmJhY2Q3YWFkNTZfbWxvN213QlF1WUZoSXlTb2dSR284aEswOFVzSmlUVGhfVG9rZW46SHdnbGJxeExLb2hlY2h4djBWSGNmcWVPblhkXzE3MzM5MjM0NDE6MTczMzkyNzA0MV9WNA)

Negate 相当于在判断条件前面加了个 `!` 取反。

例如：打印作家中年龄不大于17的作家。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .filter(new Predicate<Author>() {
                @Override
                public boolean test(Author author) {
                    return author.getAge() > 17;
                }
            }.negate())
            .forEach(System.out::println);
} 
```

转为Lambda表达式：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .filter(((Predicate<Author>) author -> author.getAge() > 17).negate())
            .forEach(System.out::println);
}
```

# 五、方法引用

方法引用（Method Reference）是 Java 8 引入的一种语法糖，用于简化 Lambda 表达式的写法。它提供了一种更简洁的方式来引用已有的方法作为函数式接口的实现。

方法引用可以看作是 Lambda 表达式的一种特殊形式，如果方法体中只有一个方法的调用的话，它可以直接引用已有的方法，而不需要编写完整的 Lambda 表达式，进而进一步简化编码。

基本格式如下：

```Java
类名或者对象名::方法名
```

方法引用的使用取决于函数式接口的抽象方法的参数和返回类型。以下是方法引用的几种形式：

- 静态方法引用：`ClassName::staticMethodName`，例如 `Integer::parseInt`。
- 实例方法引用：`instance::instanceMethodName`，例如 `String::length`。
- 对象方法引用：`ClassName::instanceMethodName`，例如 `System.out::println`。
- 构造方法引用：`ClassName::new`，例如 `ArrayList::new`。

## 静态方法引用

如果在重写方法的时候，**方法体中只有一行代码**，并且这行代码是 **调用了某个类的静态方法**，并且我们把要重写的抽象方法中所有的参数都 **按照顺序** 传入了这个静态方法中，这时候就可以通过方法引用的方式调用该静态方法。

例如，如下代码就可以用方法引用优化

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .map(author -> author.getName())
            .map(name -> String.valueOf(name))
            .forEach(name -> System.out.println(name));
}
```

注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .map(author -> author.getName())  // 也可以使用方法引用，但是这里主要是介绍静态方法引用
            .map(String::valueOf)
            .forEach(System.out::println);
}
```

## 实例方法引用

如果在重写方法的时候，方法体中 **只有一行代码**，并且这行代码是 **调用了某个对象的成员方法**，并且把要重写的抽象方法中所有的参数都按照顺序传入了这个成员方法中，这个时候就可以引用对象的实例方法。

比如上面的代码可以进一步简化：

```Java
public static void main(String[] args) {
    List<Author> authors = getAuthors();
    authors.stream()
            .map(Author::getName)
            .map(String::valueOf)
            .forEach(System.out::println);
}
```